{"pages":[{"title":"404","text":"找不到此頁面5 秒後返回首頁 返回首頁 .navbar, .article-meta.columns.is-variable.is-1.is-multiline.is-mobile.is-size-7-mobile, .footer { display: none; } .container { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); text-align: center; } h1.is-size-3 { font-size: 3rem !important; color: rgb(27, 102, 85); } .headerlink { display: none; } h3:hover::before { display: none; } .content p:not(:last-child) { margin-bottom: 2rem; } p a { padding: 0.35rem 1rem; background-color: rgb(30, 160, 142); color: white; border-radius: 20px; } p a:hover { color: white; } let countTime = 5; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if(countTime === 0){ location.href = 'https://clairechang0609.github.io/'; } setTimeout(() => { count(); }, 1000); } count();","link":"/404.html"}],"posts":[{"title":"Nuxt.js 目錄結構","text":"版本：nuxt 2.15.8 使用 create-nuxt-app 安裝完成後，可以看到以下的資料夾結構： assets, layouts, middleware, mixins, plugins 以上資料夾在當前版本是需要手動建置的， 依照順序介紹各資料夾功能： assets跟 Vue 專案相同，用來存放像是 css, scss, images 需要被 webpack 編譯的靜態資源，如不需被編譯，則存放於 static。 components自訂的元件檔，例如我們常會建立共用的 Navbar.vue, Sidebar.vue …，通常為大寫命名，然後在需要的頁面引入該檔案即可使用，使用方式基本上跟 Vue 專案相同。 如果不想要個別引入元件，Nuxt 也有提供很便利的作法，只要在 nuxt.config.js 檔內設定： // nuxt.config.jsexport default { components: true} 就會全局引入元件，使用方式只要遵循資料夾結構輸入元件名稱就可以了 範例： 元件路徑：components/home/Banner.vue 使用元件：&lt;HomeBanner&gt;&lt;/HomeBanner&gt; layouts共用模板。 大家還記得在 Vue 專案下，只要在 App.vue，或是在 router 建立一個巢狀路由，外層設定共用容器，再將嵌套路由放入 children，子路由就可以共享外層模板 export default [ { path: '/products', component: Product, children: [ { path: 'food', component: Food }, { path: 'drink', component: Drink } ] }] 但是在 Nuxt 架構下，並不存在 App.vue 這隻檔案，router 也會自動配置，那該怎麼做到模板共用呢？其實很簡單，只要在 layouts 資料夾內，新增 default.vue 檔，預設所有 pages 內的檔案都會共享該版面 // default.vue&lt;template&gt; &lt;div class=\"default-wrap\"&gt; &lt;Navbar /&gt; &lt;Nuxt /&gt; &lt;Footer /&gt; &lt;/div&gt;&lt;/template&gt; &lt;Nuxt /&gt; 類似 Vue 的 &lt;router-view /&gt; （嵌套路由） 如果想要新增更多模板，只要在 layouts 內新增檔案，例如 layouts/products.vue，在欲使用的頁面引入，該頁就可以讀到 layouts/products.vue 模板 // pages/food.vueexport default { layout: 'products'} middleware前面有說到 Nuxt 專案會自動依 pages 內的資料夾結構產生對應的靜態/動態路由， 但如果說我們想要使用 路由守衛(Navigation Guards) 來進行路由監聽，像是 Vue router 內的 beforeEach callback，該怎麼做呢？ Vue 專案：// pages/food.vueconst router = new VueRouter({ mode: 'history', routes});router.beforeEach(async (to, from, next) =&gt; { if (!store.permissions.includes(route.path)) { next({ statusCode: 403 }); } next();});export default router; Nuxt 專案：我們可以手動建立一個 middleware 資料夾，在裡面新增要進行路由監聽的檔案 routeAuth.js // middleware/routeAuth.jsexport default ({ from, route, redirect, store, error }) =&gt; { if (!store.isLogin) { redirect('/login'); } if (!store.permissions.includes(route.path)) { error({ statusCode: 403 }); }}; 然後在需要進行監聽的檔案加入 middleware // layouts/default.vueexport default { middleware: 'routeAuth', data() { return {}; }} 或是在 nuxt.config.js 設定全域監聽 // nuxt.config.jsexport default { router: { middleware: [ 'routeAuth' ] }} mixinsmixins 提供彈性方式讓頁面可以重複使用方法，可以包含任何 Vue 組件項目(data, computed, watch, 生命週期)，將共用方法包裝進去，首先在 mixins 新增檔案 mixins/utils.js // mixins/utils.jsexport default { data() { return { number: 0 }; } methods: { count() { this.number++; } }}; 全域註冊：全域宣告 mixin 務必小心使用，因為會影響到所有 Vue 檔(pages, components) 在 mixins 新增一支檔案 global-mixins.js，將欲全域註冊的檔案加入 Vue 實例 // mixins/global-mixins.jsimport Vue from 'vue';import utils from '@/mixins/utils';// 避免重複註冊if (!Vue.__utils_mixin__) { Vue.__utils_mixin__ = true; Vue.mixin(utils);} 接著加入 nuxt.config.js 內 // nuxt.config.jsexport default { plugins:[ { src: '@/mixins/global-mixins' } ]} 局部註冊：局部註冊很簡單，只要在欲使用檔案引入即可，這裡假設在 pages/about.vue // pages/about.vueimport utils from '@/mixins/utils';export default { name: 'About', mixins:[ utils ]} 這樣在 About 頁面就可以取得參數 number 的值跟呼叫 count() 方法囉！ pages主要的頁面檔案，Nuxt 專案會自動依照 pages 內的資料夾結構配置路由， 換句話說，就不需要像 Vue 專案一樣需要自行設定 vue-router，為小寫命名（命名會直接是路徑名稱），每個 .vue 檔都是已經被註冊的頁面 以首頁為例：pages/index.vue → http://localhost:3000 巢狀路由： 直接舉例，先建立一支檔案 pages/about.vue // pages/about/index.vue&lt;template&gt; &lt;div&gt; about： &lt;nuxt-child /&gt; &lt;/div&gt;&lt;/template&gt; 接在 about 資料夾新增兩隻檔案，可取得配置的巢狀路徑如下 pages/about/index.vue → http://localhost:3000/about pages/about/claire.vue → http://localhost:3000/about/claire 動態路由： 如果想要顯示動態路由，只要在檔名前加上下底線就可以了： pages/about/ _name.vue → http://localhost:3000/about/claire 這樣就可以在檔案內取得動態路由參數 // pages/about/_name.vueexport default { created () { console.log(this.$route.params.name); }} pluginsNuxt 插件，於 Vue.js 執行前引入第三方套件，以 vue-notification 為例 首先使用 npm 安裝 npm i vue-notification 然後在 plugins 資料夾新增 notification.js 檔 // plugins/notification.jsimport Vue from 'vue';import Notifications from 'vue-notification';Vue.use(Notifications); 在 nuxt.config.js 配置 plugins // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/notification.js' } ]} 就可以在所有頁面中使用該套件 &lt;Notifications&gt;&lt;/Notifications&gt; static靜態資源資料夾，用來存放不需要被編譯的檔案，像是圖片檔，或是可以供使用者下載的範例檔等，如需被編譯，則存放於 assets。 store放置 Vuex 狀態管理工具，用來存放全域共用的方法、資料，使用方式與 Vue 大致相同，Vuex 在使用時會碰到一個問題，當頁面重新整理，其會被還原為初始狀態，至於要怎麼解決這個問題，後續會單獨介紹。 參考文章： https://israynotarray.com/vue/20211011/3406447097/ https://dev.to/husteadrobert/how-to-use-global-navigation-guards-with-nuxt-middleware-and-why-you-absolutely-should-not-7bl https://ithelp.ithome.com.tw/articles/10207822 https://medium.com/@seyijosh44/how-to-use-mixins-in-nuxt-js-826724fa251","link":"/2022/11/17/nuxt/nuxt-catalog/"},{"title":"Nuxt.js 搭配 Axios 與自訂 Error Page","text":"版本：nuxt 2.15.8 Axios 是一套相當便利的 Promise Base Ajax 套件，而 Nuxt 又有 Axios 整合套件 @nuxtjs/axios，此篇範例會使用到 Async、Await，如果對於 Promise 尚不熟悉，可以參考 Promise 介紹文章 那們我們就來替專案加上 axios 吧！首先執行 npm install @nuxtjs/axios 接著在 nuxt.config.js 進行配置（參數選項）： // nuxt.config.jsexportdefault { modules: [ '@nuxtjs/axios' ], axios: { baseUrl: process.env.SERVER_URL, browserBaseURL: process.env.BASE_URL, credentials: true }} 如果需要區分 client 跟 server 端 base url，可以另外設定 browserBaseURL（於client 端會覆寫 baseUrl），套件將 axios 方法直接 注入(inject) 至 Vue 實例，擷取套件原始碼片段 // node_modules/@nuxtjs/axios/lib/plugin.js// Inject axios to the context as $axiosctx.$axios = axiosinject('axios', axios) 因此在 Vue 生命週期或屬性使用 this.$axios 即可呼叫 axios 方法，那麽在 Nuxt 生命週期呢？ Nuxt 生命週期（asyncData, fetch, plugins, middleware）會自動帶入 context 參數，context 包含以下參數 / 物件： const { $axios app, store, route, params, query, env, isDev, isHMR, redirect, error, $config} = context 使用方式如下（範例使用 asyncData） // pages/about.vueexport default { async asyncData(context) { const { seo } = await context.$axios.$get('/api/seo'); return { seo }; }} 我們也可以物件解構方式使用 $axios // pages/about.vueexport default { async asyncData({ $axios }) { const { seo } = await $axios.$get('/api/seo'); return { seo }; }} axios 提供以下方法進行事件捕捉： onRequest(config) onResponse(response) onError(err) onRequestError(err) onResponseError(err) 如果我們想要全域註冊攔截器(Interceptors) 進行 api 請求或是錯誤捕捉，也很簡單， 首先在 plugins 新增檔案，這裡命名為 axios.js，接著在裡面監聽想捕捉的事件方法 // plugins/axios.jsexport default ({ $axios, redirect, store }) =&gt; { $axios.onRequest(config =&gt; { console.log('on request', config.url); }); $axios.onError(error =&gt; { const code = parseInt(error.response &amp;&amp; error.response.status); if (code === 401) { redirect('/login'); } });}; 接著在 nuxt.config.js plugins 進行擴充 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/axios' } ]} axios 在發生錯誤時，預設會導到 error page，如果我們想避免畫面跳轉，可以加入 resolve promise，這樣在發生錯誤時，都不會跳轉到 error page // plugins/axios.jsexport default ({ $axios, redirect, store }) =&gt; { $axios.onError(error =&gt; { const code = parseInt(error.response &amp;&amp; error.response.status); if (code === 401) { redirect('/login'); } return Promise.resolve(false); // 避免畫面轉導錯誤頁 });}; 如果全域設定 resolve promise，在 axios 發生錯誤時，都不會進到 catch error 歐！ 自訂 Error Page Nuxt 專案有預設的 error page，可以在 .nuxt 資料夾看到 components/nuxt-error.vue，錯誤頁面也可以自訂，檔案放置位置比較特別，在 layouts 資料夾內新增一支檔案 error.vue // layouts/error.vue&lt;template&gt; &lt;div class=\"nuxt-error-wrap\"&gt; &lt;div class=\"text-center py-4\"&gt; &lt;h2&gt;{{ error.statusCode }}&lt;/h2&gt; &lt;h3&gt;{{ error.message }}&lt;/h3&gt; &lt;/div&gt; &lt;nuxt-link to=\"/\" class=\"btn btn-primary p-4\"&gt;回首頁&lt;/nuxt-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'ErrorPage', layout: 'error-layout', props: { error: { type: Object, default: () =&gt; {} } }};&lt;/script&gt; 雖然 error.vue 檔置於 layouts 資料夾，但視為 pages 頁面，因此如果沒有配置 layout，預設會讀取 layouts/default.vue 樣板 這樣就完成了，在 Nuxt 發生錯誤時，都會進到我們自訂錯誤頁面，如果要手動進到錯誤頁，呼叫 context 內的 error 方法即可，在 Nuxt 生命週期： // pages/about.vueexport default { async asyncData({ $axios, error }) { try { const { seo } = await $axios.$get('/api/seo'); return { seo }; } catch(err) { const { statusCode, message } = err; error({ statusCode, message }); } }} 在 Vue 生命週期或屬性，使用 this.$nuxt.error() 就可以囉！ // pages/about.vueexport default { methods: { async getSeo() { try { const { seo } = await this.$axios.$get('/api/seo'); this.seo = seo; } catch(err) { const { statusCode, message } = err; this.$nuxt.error({ statusCode, message }); } } }} 參考文章： https://ithelp.ithome.com.tw/articles/10208852 https://mavrickmaster.medium.com/custom-error-pages-with-nuxt-js-3c70e6c51aff","link":"/2022/11/21/nuxt/nuxt-axios/"},{"title":"Nuxt.js 套件應用：CKEditor 5 文字編輯器","text":"版本：nuxt 2.15.8 CKEditor 是一套歷史悠久且功能完整、輕量的富文本編輯器（rich text editor），為使用者提供所見即所得（WYSIWYG）的編輯區域，CKEditor 5 與舊版不同，使用 MVC 架構、ES6 編寫、UI 簡潔，且因應現在的前後端分離趨勢，與前端框架 React、Angular、and Vue.js 做整合，讓我們可以更便利的開發應用。 那麼我們就開始在 Nuxt 專案使用 CKEditor 5 吧，首先選擇編輯器類型（這裡使用 Classic editor），可以透過兩種方式安裝： Adding a plugin to a build如果我們想要直接使用 Classic editor 配置好的功能，不需額外擴充，此方法可以快速簡易的建置，首先安裝套件： npm install --save \\ @ckeditor/ckeditor5-vue2 \\ @ckeditor/ckeditor5-build-classic 接著在元件內加入編輯器 &lt;template&gt; &lt;div&gt; &lt;ckeditor :editor=\"editor\" v-model=\"editorData\"&gt;&lt;/ckeditor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CKEditor from '@ckeditor/ckeditor5-vue2';import ClassicEditor from '@ckeditor/ckeditor5-build-classic';export default { name: 'Editor', components: { ckeditor: CKEditor.component }, data() { return { editor: ClassicEditor, editorData: '&lt;div&gt;Hello World!&lt;/div&gt;' }; }};&lt;/script&gt; 這樣就完成了，是不是很簡單呢！ 但如果我們想擴充功能，像是新增下底線 @ckeditor/ckeditor5-basic-styles/src/underline，專案會直接報錯： Uncaught CKEditorError: ckeditor-duplicated-modules 原因是 @ckeditor/ckeditor5-build-classic 為包裝好的內容，試著進到 node_modules/@ckeditor/ckeditor5-build-classic/package.json 可以看到相依套件已經安裝進去： 因此 CKeditor 在初始化時會因為模組重複執行導致錯誤，可以改用以下方法 Adding a plugin to an editor客製化配置所有功能，步驟相對複雜，首先安裝基本套件： npm install --save \\ @ckeditor/ckeditor5-vue2 \\ @ckeditor/ckeditor5-editor-classic \\ @ckeditor/ckeditor5-dev-webpack-plugin \\ @ckeditor/ckeditor5-dev-utils \\ @ckeditor/ckeditor5-theme-lark \\ postcss@8 \\ postcss-loader@4 \\ raw-loader@4 重點步驟：需手動設定 webpack，這一步漏掉會直接報錯 // nuxt.config.jsconst path = require('path');const CKEditorWebpackPlugin = require('@ckeditor/ckeditor5-dev-webpack-plugin');const { styles } = require('@ckeditor/ckeditor5-dev-utils');export default { build: { transpile: [ /ckeditor5-[^/\\\\]+[/\\\\]src[/\\\\].+\\.js$/ ], plugins: [ // Only with ssr: false new CKEditorWebpackPlugin({ // See https://ckeditor.com/docs/ckeditor5/latest/features/ui-language.html language: 'zh', additionalLanguages: 'all', addMainLanguageTranslationsToAllAssets: true }) ], // If you don't add postcss, the CKEditor css will not work. postcss: styles.getPostCssConfig({ themeImporter: { themePath: require.resolve('@ckeditor/ckeditor5-theme-lark') }, minify: true }), extend(config) { // If you do not exclude and use raw-loader to load svg, the following errors will be caused. // Cannot read property 'getAttribute' of null const svgRule = config.module.rules.find(item =&gt; { return /svg/.test(item.test); }); svgRule.exclude = [ path.join(__dirname, 'node_modules', '@ckeditor') ]; // add svg to load raw-loader config.module.rules.push({ test: /ckeditor5-[^/\\\\]+[/\\\\]theme[/\\\\]icons[/\\\\][^/\\\\]+\\.svg$/, use: [ 'raw-loader' ] }); } }} webpack 設定說明： 語言設定：這裡設為繁體中文（’zh’） 必須在 ssr: false 條件下才能運作，否則會報錯誤 window is not defined，跟 [CKEditorWebpackPlugin] Error: No translation has been found for the XX language 排除 @ckeditor svg，並使用 raw-loader 讀取 svg 內容，否則會拋 cannot read property ‘getAttribute’ of null 錯誤 使用 PostCSS 轉換 css 代碼，否則會 css 樣式會讀取不到 接著來試著安裝編輯器功能，範例安裝 基本樣式 / 字級 / 字體： npm install --save \\ @ckeditor/ckeditor5-essentials \\ @ckeditor/ckeditor5-font \\ @ckeditor/ckeditor5-paragraph \\ 所有 ckeditor 所有套件版本必須相同，否則會發生錯誤（@ckeditor/ckeditor5-dev-* 跟 @ckeditor/ckeditor5-vue2 除外） 基礎設定介紹： placeholder：編輯器佔位符 plugins：編輯器應用功能 toolbar：工具列配置，也可以加入分隔符號 | 其他：各功能的相關設定請見官方文件 &lt;template&gt; &lt;div&gt; &lt;ckeditor :editor=\"editor\" :config=\"editorConfig\" v-model=\"editorData\"&gt;&lt;/ckeditor&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CKEditor from '@ckeditor/ckeditor5-vue2';import ClassicEditor from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';import FontFamily from '@ckeditor/ckeditor5-font/src/fontfamily';import FontSize from '@ckeditor/ckeditor5-font/src/fontsize';import Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';export default { name: 'Editor', components: { ckeditor: CKEditor.component }, data() { return { editor: ClassicEditor, editorData: '', editorConfig: { placeholder: '請輸入內容', plugins: [ Essentials, FontFamily, FontSize, Paragraph ], toolbar: { items: [ 'fontSize', 'fontFamily', '|' ], shouldNotGroupWhenFull: true }, fontSize: { options: [ 12, 16, 18, 20, 24, 32, 40, 48 ], supportAllValues: true } } }; }};&lt;/script&gt; 這樣就可以成功看到畫面囉 🙌 是否覺得功能安裝跟配置有點麻煩呢？官方貼心的提供 online-builder ，可以先挑選功能並配置好 toolbar，確認畫面後再安裝 全域註冊當專案有很多地方會使用到編輯器，我們也可以全域引入 新增檔案置於 plugins，這裡命名 ckeditor.js // plugins/ckeditor.jsimport Vue from 'vue';import CKEditor from '@ckeditor/ckeditor5-vue2';Vue.use(CKEditor); nuxt.config.js 配置 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/ckeditor' } ] } CSS style實務應用上會在後台使用編輯器來設計內容，然後將 HTML 內容儲存到資料庫，於前台取回資料並渲染在畫面上，所以會需要配置相關的 CSS，確保前後台樣式一致。 只要複製 Content styles 在專案內，然後在編輯器內容的外層容器加上 ck-content CSS class 就可以囉，範例如下： &lt;template&gt; &lt;div class=\"ck-content\"&gt; // 編輯器內容 &lt;div v-html=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 參考文章： https://github.com/changemyminds/nuxtjs-integrate-ckeditor5?ref=vuejsexamples.com https://ithelp.ithome.com.tw/articles/10198816 https://medium.com/@charming_rust_oyster_221/ckeditor-5-文字編輯器-研究心得-519c97f20a4 https://ckeditor.com/docs/ckeditor5/latest/installation/frameworks/vuejs-v2.html","link":"/2022/12/01/nuxt/nuxt-ckeditor5/"},{"title":"Nuxt.js nuxt.config.js 設定檔","text":"版本：nuxt 2.15.8 全名為 Nuxt configuration file，功能同 Vue 專案內 vue.config.js 檔，如果我們使用 create-nuxt-app 來建置專案，會自動產生這支檔案，在此配置的內容，會全域讀取設定。 接下來介紹一下一些常用的設定： alias路徑別名，大家還記得在 Vue 專案內，如果沒有設定路徑別名，則需要寫相對路徑（例如：../components/Navbar.vue），對於維護和開發都很不方便，一些程式碼檢核工具，甚至會視為 bad smell，因此我們會在 vue.config.js 檔內統一設定路徑別名。 Nuxt 專案很貼心的自動配置了路徑別名，預設值如下 { '~~': `&lt;rootDir&gt;`, '@@': `&lt;rootDir&gt;`, '~': `&lt;srcDir&gt;`, '@': `&lt;srcDir&gt;`, 'assets': `&lt;srcDir&gt;/assets`, // (unless you have set a custom `dir.assets`) 'static': `&lt;srcDir&gt;/static`, // (unless you have set a custom `dir.static`)} 因此在引入元件 Navbar 時可以寫成 @/components/Navbar.vue 如果需要更改配置也可以 import { resolve } from 'path';export default { alias: { 'images': resolve(__dirname, './assets/images'), '@static': resolve(__dirname, './static') }} ssrserver side render，預設為 true，如果不需 SEO，只要 spa 操作，設定 ssr: false 即可 舊版會使用 mode: 'spa' 來進行設定，但官方文件有說明 v2.14.5 版本開始已棄用，改用 ssr: false export default { ssr: false // spa} server用來設定 port（預設 3000） 跟 host（預設 localhost） export default { server: { port: 8000, host: 'my-website' }} router配置 Nuxt 路由（vue-router），這裡以設定 base url 舉例，其他請參考官方文件 export default { router: { base: '/backoffice/' }} head在 Vue 專案，我們要設定 head 內容，只要在 public/index.html 檔設定就好了，但 Nuxt 專案又該怎麼設定呢？ 全域設定在 nuxt.config.js 檔 head 內即可全域設定，通常在建立專案會預先帶入 export default { head: { title: 'test', htmlAttrs: { lang: 'en' }, meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: '' }, { name: 'format-detection', content: 'telephone=no' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] }} 這樣所有頁面都可以讀到 head 設定 單頁設定Nuxt 專案很重要的一點是 SEO 效能優化，基於這點，通常會需要依照各頁設定自己的 SEO，例如pages/about.vue 頁面的 title 和 description 要單獨設定，方法也很簡單 export default { head: { title: '關於我們', meta: [ { hid: 'description', name: 'description', content: '這是關於我們頁面' } ] }} 在各頁面設定的內容優先度較高，會覆寫全域設定的 head 內容，因此當我們開啟 about 頁面，會看到 title 變成 關於我們、description 變成 這是關於我們頁面，其他配置則依照 nuxt.config.js 檔 css引入全域使用的 css 檔，像是外部套件，或是自訂檔，如果要使用 sass，必須安裝 sass-loader npm install --save-dev sass sass-loader export default { css: [ // 外部套件 { src: 'bootstrap-icons/font/bootstrap-icons.css' }, // scss 檔 { src: '@/assets/scss/app.scss', lang: 'scss' } ]} plugins全局引入外部套件，以 vue-notification 舉例，在 plugins 新增 notification.js 檔 // plugins/notification.jsimport Vue from 'vue';import Notifications from 'vue-notification';Vue.use(Notifications); 在 nuxt.config.js 配置 plugins export default { plugins: [ { src: '@/plugins/notification.js' } ]} 就可以在所有頁面中使用該套件 &lt;Notifications&gt;&lt;/Notifications&gt; components如設定為 true，會全局引入元件，使用方式只要遵循資料夾結構輸入元件名稱就可以了 export default { components: true} 範例： 元件路徑：components/home/Banner.vue 使用元件：&lt;HomeBanner&gt;&lt;/HomeBanner&gt; buildModules用來配置只在開發環境使用的模組，註冊在此可以讓專案在生產環境部署速度提升，並減少 node_modules 容量，詳情可以參考各套件的配置建議 @nuxtjs/eslint-module 套件官方建議配置於 buildModules export default { buildModules: [ '@nuxtjs/eslint-module' ]} 使用條件：Nuxt 版本必須大於 v2.9 modules用來配置開發環境與生產環境共用模組，buildModules 及 modules 配置位置詳請參考各套件建議 export default { modules: [ '@nuxtjs/style-resources' ]} styleResources用來注入全域共用 sass, scss，如果不引入，在各頁面（.vue）內的 style 會無法使用像是 mixin 等的常用變數，或是要在各頁面單獨 @import scss 檔 首先必須另外安裝 @nuxtjs/style-resources 套件 執行：npm i @nuxtjs/style-resources 在 nuxt.config.js 檔設定 export default { modules: [ '@nuxtjs/style-resources' ], styleResources: { scss: [ '@/assets/scss/components/_color.scss', '@/assets/scss/components/_mixin.scss' ] }} 這樣就可以達到變數共用了 官方文件 提到，請勿引入實際的 css 樣式，因為每個頁面跟元件都會重複編譯，造成系統極大負擔（筆者踩坑過OQ），建議只注入變數, mixins，因為這些值在編譯後就會消失了。 build客製化 webpack 設定，這裡舉例，在開發時，發現在 Vue 樣板無法使用可選串連 Optional Chaining（es2020語法），研究後發現必須需安裝擴充套件 npm install vue-template-babel-compiler --save-dev 接著在 nuxt.config.js 檔設定，就可以成功使用囉 export default { build: { loaders: { vue: { compiler: require('vue-template-babel-compiler') } } }} LoadingLoading 效果，基礎設定如下（參數選項） export default { loading: { color: 'black', height: '5px', continuous: true }} 如果想自訂更多樣式，也可以包裝成元件後引入 export default { loading: '@/components/TheLoading.vue'} env用來定義全局共用的環境變數，Nuxt 專案預設只有 nuxt.config.js 檔內可以讀取環境變數， 因此如果要讓 .vue 檔或是 .js 檔讀到變數，這裡提供以下兩個做法： 方法一：直接在 nuxt.config.js 檔內配置屬性export default { env: { BASE_URL: process.env.BASE_URL }} 但有時變數多，不想各別配置，可以採用方法二 方法二：安裝套件 @nuxtjs/dotenv執行：npm i @nuxtjs/dotenv，在 modules 內設定： export default { modules: [ '@nuxtjs/dotenv' ]} 這樣就可以全域使用 .env 變數囉。 專案如果有區分開發跟生產環境 .env 檔，也可以設定如下： export default { modules: [ [ '@nuxtjs/dotenv', { filename: `.env.${process.env.ENV}` } ] ]} 使用方法二需注意，變數如果內含變數，會讀取不到第二層的變數（饒口），直接提供範例，假設在 .env 檔內有兩個變數BASE_DOMAIN=my-websitesBASE_URL=\"http://${BASE_DOMAIN}\"在 .vue 檔直接使用 process.env.BASE_URL，取得值為 http://${BASE_DOMAIN}，無法解析成 http://my-websites，此情況還是需搭配方法一使用 參考文章： https://ithelp.ithome.com.tw/articles/10207330 https://nuxtjs.org/docs/configuration-glossary https://hackmd.io/@xq/nuxt-config","link":"/2022/11/19/nuxt/nuxt-config-setting/"},{"title":"Nuxt.js 設定 GA & GTM","text":"版本：nuxt 2.15.8 網站上線後，我們會需要 Google Analytics 和 Google Tag Manager 工具來追蹤分析網站流量，接下來說明如何在 Nuxt.js 專案內加入追蹤碼。 Google Analytics申請代碼： 至 Google Analytics 分析，使用 google 帳戶登入，點選左下角的管理 選擇建立資源 設定資源名稱，選項勾選後，點選建立 選擇資料串流平台：網站 設定網站網址跟串流名稱，接著就新增成功並取得 GA 代碼。 設定代碼：搭配套件 vue-gtag ，執行：npm i vue-gtag@1.16.1 Vue v2.x 需搭配 vue-gtag v1.x 接著我們新增檔案至 plugins，這裡命名為 gtag.js import Vue from 'vue';import VueGtag from 'vue-gtag';Vue.use(VueGtag, { config: { id: 'UA-XXXXXXXXX-X' }}); 配置到 nuxt.config.js export default { plugins: [ { src: '@/plugins/gtag.js' } ]} Google Tag Manager申請代碼： 至 Google Tag Manager 代碼管理工具，使用 google 帳戶登入並建立帳戶 設定帳戶名稱（命名一個容易辨識網站的名稱），接著設定容器（GTM 要放入的網域），按下建立，就可以看到新增的容器跟 GTM 代碼囉 設定代碼：搭配套件 @nuxtjs/gtm ，執行：npm i @nuxtjs/gtm，然後配置 nuxt.config.js export default { modules: [ '@nuxtjs/gtm', ], gtm: { id: 'GTM-XXXXXXX' }} 預設內容 參考，也可以調整設定 export default { modules: [ '@nuxtjs/gtm', ], gtm: { id: 'GTM-XXXXXXX', enabled: true, // for dev mode pageTracking: true }} 如果代碼都是固定的內容，這樣就完成囉～ 不過事情總沒這麼簡單，如果今天專案有後台，GA 跟 GTM 都可供使用者設定，代碼都是變動的參數，又該怎麼做呢？ 整合後端 API 進行代碼設定這裡同時說明 GA 跟 GTM 的配置，首先安裝套件 npm i vue-gtag@1.16.1 npm i @nuxtjs/gtm 由於要串接 API，這裡搭配 @nuxtjs/axios 使用，執行：npm i @nuxtjs/axios 新增 plugins/gtag.js import Vue from 'vue';import VueGtag from 'vue-gtag';export default async ({ $gtm, $axios }) =&gt; { const { gaFour, gtm } = await $axios.$get('/api/ga'); // GA4 Vue.use(VueGtag, { config: { id: gaFour } }); // GTM if (gtm) { $gtm.init(gtm); }}; 配置 nuxt.config.js export default { plugins: [ { src: '@/plugins/gtag.js' } ], modules: [ '@nuxtjs/gtm' ], gtm: { enabled: true, pageTracking: true }} 參考文章： https://www.turingdigital.com.tw/blog/install-ga4-property https://www.cyberbiz.io/support/?p=228 https://stackoverflow.com/questions/64612031/setup-google-analytics-4-in-nuxt-js","link":"/2022/12/14/nuxt/nuxt-ga-and-gtm/"},{"title":"Nuxt.js 專案架設","text":"版本：nuxt 2.15.8 說到 Nuxt，必須先從 Vue.js 說起，Vue.js 為專注在視圖層(View) 的 JS 框架，為 SPA（Single Page Application）應用程式，簡而言之整個網站應用只有單一頁面，一但頁面被加載進來後，就不會再進行該頁面請求，由於 Vue 是利用 JS 載入資料，並動態產生元件，SEO 只能抓取到 HTML 內容，因此 SEO 表現趨近於零。 而 Nuxt 是基於 Vue.js、Node.js、Webpack 以及 Badel.js 的輕量框架，可以同時創建 SSR（Server Side Render）及 SPA，在頁面載入前即渲染（伺服器回傳完整 HTML 檔，每次跳轉頁面，瀏覽器都需要刷新），搜尋引擎爬蟲可以取得資料，大幅解決 SEO 的問題。 以下圖片說明： 接下來一起來嘗試創建一個 Nuxt 專案吧！ 如同 Vue CLI，Nuxt 也有類似的指令列(command-line)工具 create-nuxt-app， 依據官方文件提供的專案包建置方式： npx create-nuxt-app &lt;project-name&gt; 使用 npx 安裝，安裝的套件在執行完後就會被移除 npx介紹 接著會跑出一些選項： Project name：設定專案名稱 Programming language：選擇程式語言 Package manager：軟體套件管理系統 npm / yarn UI framework：css 模板 Template engine：樣版引擎 Nuxt.js modules：相依套件 Linting tools：程式碼檢查工具 Testing framework：測試工具 Rendering mode：渲染模式 Deployment target：運行模式 （在此示範 Server Side Render) Development tools：開發工具 Version control system：版控工具 以上選擇完畢就開始安裝專案包 運行完成就可以開始編譯專案 跟著提示訊息執行： cd testnpm run dev 在 package.json 內可以看到相關指令 \"scripts\": { \"dev\": \"nuxt\", \"build\": \"nuxt build\", \"start\": \"nuxt start\", \"generate\": \"nuxt generate\"} 接下來就可以看到畫面囉 👏 參考文章： https://medium.com/web-design-zone/建立nuxt-js專案初體驗-21920735e38b https://levelup.gitconnected.com/spa-ssg-ssr-and-jamstack-a-front-end-acronyms-guide-6add9543f24d","link":"/2022/11/16/nuxt/nuxt-installation/"},{"title":"Nuxt.js Lifecycle 生命週期","text":"版本：nuxt 2.15.8 Nuxt 最大的特點就是 Server Side Render，因此他有獨立的生命週期，來看一下官方提供的圖片： nuxtServerInit只在 Nuxt 環境初始化時觸發，當我們想將 server 端資料提前傳給 client 端，可以使用此方法，要注意只能寫在 VueX store/index.js actions // store/index.jsexport const state = () =&gt; ({ userInfo: {}});export const mutations = { setUserInfo(state, value) { state.userInfo = value; }};export const actions = { nuxtServerInit({ commit }, { req }) { // req.session.user = { name: 'claire' } commit('setUserInfo', req.session.user); }}; 這樣就可以在 Nuxt 初始化時，觸發 nuxtServerInit 方法，將值傳入 state，我們可以從瀏覽器 Vue 開發者工具看到內容： 如果想將資料傳給其他 VueX modules，可以這樣做： 首先新增一支檔案 store/greeting.js // store/greeting.jsexport const state = () =&gt; ({ message: ''});export const mutations = { setMessage(state, value) { state.message = value; }}; 接著在 store/index.js 定義 nuxtServerInit // store/index.jsexport const actions = { nuxtServerInit({ commit }, { req }) { commit('greeting/setMessage', 'Hello World!'); }}; 這樣就可以觸發 store/greeting.js setMessage 方法，見下圖開發者工具 Route Middleware中間組件，在頁面渲染前執行，有三種定義方式，執行順序為：Global → Layout → Page 接下來分別說明該如何定義 Global Middleware在 middleware 資料夾內建立檔案，這裡命名為 global.js // middleware/global.jsexport default ({ from, route, redirect, store, error }) =&gt; { console.log('global middleware'); if (!store.isLogin) { redirect('/login'); }}; 接著在 nuxt.config.js 配置 // nuxt.config.jsexport default { router: { middleware: [ 'global' ] }} Layout Middleware建立 middleware 檔案，這裡命名為 middleware/layout.js，然後配置到任一 layouts 檔案，範例使用 layouts/default.vue // layouts/default.vueexport default { name: 'Default', middleware: 'layout'}; 或是匿名配置也可以： // layouts/default.vueexport default { name: 'Default', middleware({ from, route, redirect, store, error }) { console.log('layout middleware'); }}; Page Middleware概念同 layouts middleware，配置於任一 pages 檔案，範例使用 pages/about.vue，這裡使用匿名配置來說明 // pages/about.vueexport default { name: 'About', middleware({ from, route, redirect, store, error }) { console.log('page middleware'); }}; 接著我們從開發者工具查看 console 結果依序為下圖，因此我們可以透過 layout 跟 page middleware 來覆寫 global middleware validate於 pages 檔案配置此方法，用來驗證動態路由參數有效性，範例使用 pages/about/_userId.vue // pages/about/_userId.vueexport default { name: 'User', validate({ params, query }) { return true; // 驗證通過 return false; // 驗證無效，會自動轉導 error page }} 驗證通過必須 return true，否則會自動轉跳 404 error page asyncData於 server 端處理非同步的生命週期，在此傳入的內容可以被搜尋引擎爬蟲取得，是提升 SEO 效能的重點生命週期。 只會在頁面載入時調用，由於生命週期在 Vue 之前，因此無法取得 this ，且 asyncData 僅限 pages 底下頁面使用，方法內會自動帶入 context 參數，我們可以安裝 @nuxtjs/axios 套件，axios 會被注入進 context 內，我們可以物件解構方式使用（ { $axios, params } = context )（範例使用 pages/about.vue） // pages/about.vueexport default { name: 'About', async asyncData({ $axios, params }) { const id = params.id; const { data } = await $axios.$get(`/api/user/${id}`); return { userName: data }; }} 透過 return value，資料被賦予進 Vue 實體，我們透過 this.userName 即可成功取值 // pages/about.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ userName }}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'About', async asyncData({ $axios, params }) { const id = params.id; const { data } = await $axios.$get(`/api/user/${id}`); return { userName: data }; }}&lt;/script&gt; data 如果有相同變數名稱，會在 asyncData 生命週期被複寫，所以除非需要再次修改變數，否則請避免重複命名變數 asyncData 是在 server 端、路由更新前即調用，由於是在瀏覽器渲染前的生命週期，因此無法使用 loading placeholder，也不能使用瀏覽器相關 API fetchNuxt v2.12 新增功能，功能類似 asyncData ，在畫面渲染前，同時於 server 端跟 client 端的生命週期，可以使用於任一 .vue 頁面，由於是在 Vue created 之後，因此可以取得 this，初次載入頁面時，fetch 會在 server 端執行，如果是透過 &lt;nuxt-link&gt; 進行路由切換，fetch 在 client 端執行，因此可以在此生命週期加入 loading 效果 &lt;nuxt-link&gt; 為 Nuxt 的路由切換元件，相當於 Vue.js 的 &lt;router-link&gt; ，因此我們只能使用內部連結，外部連結必須使用 &lt;a&gt; 標籤，透過 &lt;nuxt-link&gt; 切換路由，會被視為 SPA 頁面跳轉 以下說明使用方式 &lt;template&gt; &lt;ul&gt; &lt;li v-for=\"(post, key) in posts\" :key=\"key\"&gt; {{ post }} &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { posts: [] } }, async fetch() { const { data } = await this.$axios.$get('/api/posts'); this.posts = data; }}&lt;/script&gt; 如果要重複觸發 fetch 生命週期，可以使用 this.$fetch 來呼叫： &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=\"(post, key) in posts\" :key=\"key\"&gt; {{ post }} &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"$fetch\"&gt;重新取得貼文&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 如果我們希望 fetch 只在 client 端運行，可以加上 fetchOnServer: false（預設 true） 取得 fetch 狀態我們可以透過 this.$fetchState 取得 fetch 當前執行狀態，有以下參數： pending：Boolean / 是否執行完成，可以在此加入 loading 效果（client 端） error：null or Error 物件 / 判斷是否發生錯誤 timestamp：整數 / 最後一次執行時間（搭配 activated 使用） 範例： &lt;template&gt; &lt;div&gt; &lt;p v-if=\"$fetchState.pending\"&gt;Loading...&lt;/p&gt; &lt;p v-if=\"$fetchState.error\"&gt;有東西出錯了&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { posts: [] } }, activated() { // 每 30 秒自動呼叫 fetch if (this.$fetchState.timestamp &lt;= Date.now() - 30000) { this.$fetch() } }, async fetch() { const { data } = await this.$axios.$get('/api/posts'); this.posts = data; }}&lt;/script&gt; 生命週期執行順序接著我們從瀏覽器開發者工具觀察生命週期執行順序 asyncData() { console.log('asyncData');},fetch() { console.log('fetch');},beforeCreate() { console.log('beforeCreate');},created() { console.log('created');},beforeMount() { console.log('beforeMount');} 可以發現，created 跟 beforeCreate 這兩個 Vue.js 生命週期會同時出現在 server 端跟 client 端，如果要避免方法被重複執行，可以這樣做： 加上 process.client 判斷 created(){ if (process.client){ // 執行內容 }} 使用 Nuxt fetch 生命週期 使用 Vue beforeMount 生命週期 參考文章： https://stackoverflow.com/questions/60411436/nuxtjs-page-is-created-twice https://happy9990929.github.io/2021/09/10/vue-nuxt-lifecycle-hooks/","link":"/2022/11/24/nuxt/nuxt-lifecycle/"},{"title":"Nuxt.js Meta Tags and SEO","text":"版本：nuxt 2.15.8 在 Vue.js 專案，我們可以直接在 index.html &lt;head&gt; 設定全站共用的 meta tags，那在 Nuxt 又該怎麼設定呢？ Nuxt.js 藉由 vue-meta 來更新應用內的 head 設定跟 meta 屬性，使用 create-nuxt-app 建構專案會自動安裝，我們可以在頁面定義不同的內容，幫助搜尋引擎爬蟲掌握頁面內容，提升 SEO。 全域配置export default { head: { title: 'my website title', meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: 'my website description' }, { hid: 'og:title', property: 'og:title', content: 'my website title' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] }} 我們可以看到 head 自動渲染： &lt;head&gt; &lt;title&gt;my website title&lt;/title&gt; &lt;meta data-n-head=\"ssr\" charset=\"utf-8\"&gt;&lt;/head&gt; 為了避免元件內 局部配置 head 造成 meta tags 重複，需加上 hid key，並賦予唯一值，這樣當元件定義相同 hid 的 meta 標籤，vue-meta 會自動覆蓋掉 全域配置 局部配置以物件定義： export default { head: { title: 'about-us', meta: [ { hid: 'description', name: 'description', content: 'about-us' } ] }} 如果需要透過 this 來取得 meta 資料，需要調整為 function return： export default { data() { return { seo: { title: 'about-us', description: 'about-us' } } }, head() { return { title: this.seo.title, meta: [ { hid: 'description', name: 'description', content: this.seo.description } ] } }} 參考文章： https://nuxtjs.org/docs/features/meta-tags-seo/","link":"/2022/12/10/nuxt/nuxt-meta-tags/"},{"title":"Nuxt.js 替網站增加 sitemap 網站地圖","text":"版本：nuxt 2.15.8 當我們的新網站上線，外部連結少，或是網站規模很大時，透過 sitemap 網站地圖，可以讓 google 搜尋引擎爬蟲可以更快速的了解我們的網站上有哪些網頁並加以收錄，並建立索引，提升網頁出現的機率。 我們可以透過 @nuxtjs/sitemap 來快速建立 sitemap，執行：npm i @nuxtjs/sitemap 在 config 資料夾新增 sitemap.js 檔案，接著在 nuxt.config.js 配置： import sitemap from './config/sitemap';export default { modules: [ '@nuxtjs/sitemap', ], sitemap: sitemap} 接著移動到到 config/sitemap.js 進行設定。 sitemap 選項說明： path：設定 sitemap 名稱，預設為 ****/sitemap.xml hostname：網站 domain cacheTime：sitemap 更新的頻率（預設為 1000 * 60 * 15 15 分鐘） gzip：是否生成壓縮檔，預設 false exclude：排除被加進 sitemap 的頁面（陣列） sitemap: { exclude: [ '/guideline', '/sample/**' ]} defaults：預設設定（自動帶入 routes） sitemap: { defaults: { changefreq: 'daily', // 更新頻率 priority: 0.8, // 優先度 lastmod: new Date() // 最後更新時間 }} filter：篩選路徑（function） sitemap: { filter({ routes }) { return routes.map(route =&gt; { // 設定首頁優先度為 1 if (route.url === '/') { route.priority = 1; } return route; }); }} routes：加入路徑（本篇重點，以下詳細說明） Routes 設定@nuxtjs/sitemap 會自動加入 靜態路由 頁面，但 動態路由 必須手動加入 -| pages/---| index.vue --&gt; static route---| about.vue --&gt; static route---| users/-----| _id.vue --&gt; dynamic route 加入動態路由方法： 手動加入（使用陣列） sitemap: { routes: [ { url: '/users/1', changefreq: 'daily', priority: 0.6, lastmod: new Date() }, { url: '/users/2', changefreq: 'daily', priority: 0.6, lastmod: new Date() } ]} 透過 API 串接加入（使用 function 回傳 promise） 範例會使用 @nuxtjs/axios 進行 API 串接，執行：npm i @nuxtjs/axios sitemap: { routes: async () =&gt; { const { data } = await axios.get('https://test/api/sitemap'); return data.map(user =&gt; { return { url: `/users/${user.id}`, changefreq: 'daily', priority: 0.6, lastmod: new Date() } }); }} 將上述設定合併起來： const axios = require('axios');const sitemap = { path: '/sitemap.xml', // sitemap 名稱 hostname: 'https://test.com', // domain cacheTime: 1000 * 60 * 60 * 24, // update frequency of the day defaults: { changefreq: 'daily', priority: 0.8, lastmod: new Date() }, filter({ routes }) { return routes.map(route =&gt; { if (route.url === '/') { route.priority = 1; } return route; }); } routes: async () =&gt; { const { data } = await axios.get('https://test.com/api/sitemap'); return data.map(user =&gt; { return { url: `/users/${user.id}`, changefreq: 'daily', priority: 0.6, lastmod: new Date() } }); }};export default sitemap; 接著在頁面上輸入 hostname/sitemap.xml（EX：https://test.com/sitemap.xml），就可以看到我們的 sitemap 檔案囉 🙌 參考文章： https://www.hellosanta.com.tw/knowledge/category-13/post-236 https://sitemap.nuxtjs.org/usage/sitemap-options","link":"/2022/12/15/nuxt/nuxt-sitemap/"},{"title":"Nuxt.js VueX Store 搭配 vuex-persistedstate 狀態保存工具","text":"版本：nuxt 2.15.8 前情提要一下，在 Vue 的專案下，常會需要做父子元件或是頁面之間的溝通傳值，如果說只是單層（ex：父元件 → 子元件、子元件 → 父元件、頁面 → 頁面），我們可以很簡單的使用 props 、 emit 或 event bus 即可，但在大型專案，共用資料就不是如此單純，可能會有元件內含元件、多層級的溝通，如果只用上述方法，對於開發及除錯都不便利，如下圖範例，元件 1-1 跟元件 2-1 的溝通相對複雜。 為了處理高難度溝通，VueX 狀態管理工具就誕生了，那麼在 Nuxt 專案下又該怎麼使用呢？ 首先先安裝 VueX 套件 npm i vuex@3.6.2 Nuxt v2.x 必須搭配 VueX v3.x 接著在專案最外層新增 store 資料夾，並在裡面建立 .js 檔，範例使用 userInfo.js // store/userInfo.jsexport const state = () =&gt; {};export const getters = {};export const mutations = {};export const actions = {}; Nuxt 專案會自動創建實例 new Vuex.Store()，將 store 檔案包裝進模組內，像這樣： new Vuex.Store({ modules: { userInfo: { namespaced: true, state: () =&gt; {}, getters: {}, mutations: {}, actions: {} } }}); VueX 基本架構： state：用以儲存狀態，功能同 .vue 檔內的 data，因此會使用方法來包裝，並 return 內容 getters：功能同 computed，用以計算 state 內的狀態，不能直接改變 state mutations：用來更改 state，不能使用非同步語法 actions：非同步語法只能寫在 actions，不能直接改變 state，需透過 mutations 改變 state 接著來替 store 加入一些內容吧 // store/userInfo.jsexport const state = () =&gt; ({ count: 0, products: [ { name: 'food', onSale: false }, { name: 'drink', onSale: true } ]});export const getters = { onSaleProducts(state) { return state.products.filter(item =&gt; item.onSale); }};export const mutations = { increment(state, number) { state.count += number; }};export const actions = { incrementAsync({ commit }, number) { setTimeout(() =&gt; { commit('increment', number); }, 1000); }}; 如果要在頁面使用 store 的內容，有以下兩種方式： 透過 this.$store 操作VueX 將 store 注入到 Vue 實例，因此我們透過 $store 就可以取得相關資料及方法，使用方式如下（範例頁面 pages/about.vue）： // pages/about.vueexport default { name: 'About', computed: { count() { // state return this.$store.state.userInfo.count; } onSaleProducts() { // getters return this.$store.getters['userInfo/onSaleProducts']; } }, methods: { increment(number) { // mutations this.$store.commit('userInfo/increment', number); }, incrementAsync(number) { // actions this.$store.dispatch('userInfo/incrementAsync', number); } }} 但是每一筆資料或是方法，都透過 this.$store 取得，程式碼冗長，如果今天我們有三個 store 儲存庫，易讀性又更低了，難道沒有簡單的使用方式嗎？ 透過輔助函式VueX 提供一系列輔助函式（mapState, mapGetters, mapMutations, mapActions），可以幫助我們更簡易的取得 store 內容，首先必須從 VueX 引入輔助函式，接著來改寫 about.vue 頁面 // pages/about.vueimport { mapState, mapGetters, mapMutations, mapActions } from 'vuex';export default { name: 'About', computed: { ...mapState('userInfo', [ 'count' ]), ...mapGetters('userInfo', [ 'onSaleProducts' ]) }, methods: { ...mapMutations('userInfo', [ 'increment' ]), ...mapActions('userInfo', [ 'incrementAsync' ]) }} 透過輔助函式，減少許多程式碼，閱讀起來也輕鬆許多。 VueX 相當方便，但還是存在一個問題，就是當頁面重新整理的時候，會回復到初始狀態。 某些情境下，我們需要保留更新後的資料，例如登入後儲存使用者資訊到 store，重整頁面後資料被清空，使用者必須重新登入。為了解決這個問題，我們可以將資料儲存於 localStorage，待畫面重整後再將資料取回放入 store，或者是使用套件 vuex-persistedstate 2022.02.04 vuex-persistedstate 套件已不繼續維護更新 接下來說明如何 Nuxt 專案如何搭配 vuex-persistedstate，存放在 localStorage 的內容，可以輕易地被讀取，因此我們需要將內容加密（搭配套件 secure-ls） 首先安裝套件：npm i vuex-persistedstate 及加密套件：npm i secure-ls，接著於 plugins 增加檔案，範例使用 persistedstate.js // plugins/persistedstate.jsimport createPersistedState from 'vuex-persistedstate';import SecureLS from 'secure-ls';const ls = new SecureLS({ encodingType: 'aes', // 加密方式，預設 base64 isCompression: false, // 是否壓縮數據 encryptionSecret: process.env.APP_KEY // 加密 key});export default ({ store, isHMR }) =&gt; { if (isHMR) { // 避免在熱更新的時候重複觸發(npm run dev) return; } window.onNuxtReady(() =&gt; { createPersistedState({ key: 'test', // 自訂 localStorage key storage: { getItem: key =&gt; ls.get(key), setItem: (key, value) =&gt; ls.set(key, value), removeItem: key =&gt; ls.remove(key) } })(store); });}; 接著配置到 nuxt.config.js 內 // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/persistedstate', ssr: false } ]} 這樣一來即使畫面重整，store 也可以順利保存資料，在 localStorage 查看 test 內容也確實被加密了！ 參考文章： https://medium.com/itsems-frontend/vue-vuex1-state-mutations-364163b3acac https://chiafangsung.medium.com/使用-vuex-persistedstate-維持-vuex-狀態-f0d7c522c73a","link":"/2022/11/22/nuxt/nuxt-vuex-store/"},{"title":"Nuxt.js 套件應用：Swiper 製作輪播動畫","text":"版本：nuxt 2.15.8 網站開發常使用到輪播功能，Swiper 是一款基於 js 開發、功能完整實用性高的輪播套件，今天來介紹如何在 Nuxt.js 專案內應用，我們會搭配 Vue 整合套件 vue-awesome-swiper 使用 套件安裝： npm i swiper@6.8.4 npm i vue-awesome-swiper@4.1.1 官方文件版本說明：Vue2 搭配 Swiper 5-6 ＆&nbsp;vue-awesome-swiper@4.1.1如果是 Vue3 此套件已不支援，可以直接使用 Swiper Vue 版本 接下來全域註冊 Swiper 元件，在 plugins 資料夾新增檔案（範例命名 swiper.js） // plugins/swiper.jsimport Vue from 'vue';import Swiper, { /* swiper modules... */ } from 'swiper';import VueAwesomeSwiper from 'vue-awesome-swiper';Swiper.use([ /* swiper modules... */ ]);export default () =&gt; { Vue.use(VueAwesomeSwiper);}; 上述 swiper modules 區塊可以替換需要的模組（模組選項），範例使用 Navigation, Pagination 然後在 nuxt.config.js 進行配置 // nuxt.config.jsexport default { css: [ { src: 'swiper/swiper-bundle.min.css' } ], plugins: [ { src: '@/plugins/swiper', mode: 'client' } ]} 重頭戲來了，我們可以透過兩種方式在頁面上使用： swiper components 元件&lt;template&gt; &lt;client-only&gt; &lt;div&gt; &lt;swiper class=\"swiper\" :options=\"swiperOption\" ref=\"bannerSwiper\"&gt; &lt;swiper-slide&gt;banner 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 2&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 3&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 4&lt;/swiper-slide&gt; &lt;swiper-slide&gt;banner 5&lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;div class=\"swiper-button-prev\" slot=\"button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\" slot=\"button-next\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/client-only&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { swiperOption: { slidesPerView: 3, spaceBetween: 5, grabCursor: true } } }};&lt;/script&gt; swiper 設定項目請見文件，如果專案為 server-side render，使用此方式外層需加上 &lt;client-only /&gt; ，否則在 server 端會因為 dom 元素無法被解析而報錯 [Vue warn]: The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside &lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing full client-side render. 我們可以使用 this.$refs.bannerSwiper.$swiper 來取得 Swiper 實體並使用相關方法 根據文件說明，&lt;client-only /&gt; 的元素會在 mounted 生命週期才執行，因此在 mounted 呼叫 $refs 可能會得到取不到內容（即使使用 $nextTick 也可能取不到），可以這樣包裝： export default { mounted(){ this.getSwiperInstance() }, methods: { getSwiperInstance() { this.$nextTick(() =&gt; { if (this.$refs.bannerSwiper) { this.$refs.bannerSwiper.$swiper.slideTo(2); } else { this.getSwiperInstance(); } }); } }} directive 指令如果 Swiper 內容需要被搜尋引擎爬蟲讀取，可以利用 Vue directive 方法，這樣就可以使用能被瀏覽器解析的 dom 元素來包裝 swiper，見以下範例 &lt;template&gt; &lt;div class=\"banner-wrap mx-auto py-4 px-3\"&gt; &lt;div v-swiper:bannerSwiper=\"swiperOption\" class=\"swiper\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;banner 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 3&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 4&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;banner 5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { swiperOption: { slidesPerView: 3, spaceBetween: 5, grabCursor: true } } }, mounted() { this.bannerSwiper.slideTo(2, 500, false); }};&lt;/script&gt; 如果同一個頁面有多個 Swipers，必須要透過命名（ ex: v-swiper:bannerSwiper ）來進行綁定，否則會無法正常操作，我們也可以透過名稱 this.bannerSwiper 的取得 Swiper 實體並使用相關方法，是不是簡單許多呢！ 參考文章： https://github.com/surmon-china/surmon-china.github.io/blob/vue2/projects/vue-awesome-swiper/examples/00-typescript-composition-api.vue https://nuxtjs.org/docs/features/nuxt-components/#the-client-only-component https://ken551113.github.io/2019/11/26/Using-Vue-Awesome-Swiper-On-Nuxt/","link":"/2022/11/29/nuxt/nuxt-swiper/"},{"title":"Vue.js 圖片上傳串接後端 API（轉換成base64格式）","text":"版本：vue 2.6.14 這次介紹的上傳步驟為，使用者填寫一份表單，在選取欲上傳圖片後，系統會先將檔案上傳至雲端資料庫，待使用者確認整份表單填寫無誤後，才送出表單。 操作步驟： 點擊 input 選擇本地端圖片 進行圖片轉換（轉成 base64 格式） 呼叫後端 api 進行上傳（至雲端資料庫） 成功回傳圖片路徑 將該路徑顯示於畫面預覽 HTML說明： accept：檔案接受格式 &lt;input type=\"file\" ref=\"image-input\" accept=\"image/jpeg, image/png\" @change=\"changeImage()\" /&gt;&lt;img :src=\"image\" :alt=\"image\" /&gt; Javascript點擊圖片觸發 changeImage 方法： 注意：vue 語法糖 v-model 綁定的是 v-on:input 事件，因此 input[type=file] 不適用 說明： FileReader 為 javascript 物件，能以非同步方式（在此使用到 onload 事件）讀取儲存在用戶端的檔案內容，讀取格式可為可&nbsp;File 或&nbsp;Blob 物件 readAsDataURL 方法會讀取指定的&nbsp;File 或&nbsp;Blob 物件，讀取完成後將其轉換成 base64 格式 changeImage() { const input = this.$refs['image-input']; const file = input.files[0]; // reset input，避免使用者重複選同一檔案無法觸發 change 事件 input.files = new DataTransfer().files; // 檢查圖片檔大小 if (!this.checkFileSize(file)) { return; } // 上傳圖片 this.uploadImage(file);} checkFileSize(file) { // 限制 1 MB if (file.size &gt; (1024 * 1024)) { this.$notify({ type: 'danger', text: '檔案大小不可大於 1 MB' }); return false; } return true;} FileReader 正式上場！ uploadImage(file) { const reader = new FileReader(); reader.readAsDataURL(file); reader.addEventListener('load', async () =&gt; { const apiUrl = '/api/v1/image'; // api url const configData = { file }; const response = await this.$axios.$post(apiUrl, configData); this.image = response.image; });} 最後就可以把 api 呼叫成功回傳回來的圖片路徑渲染在畫面上啦！大功告成。","link":"/2022/11/03/vue/vue-upload-image/"}],"tags":[{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"nuxt.js","slug":"nuxt-js","link":"/tags/nuxt-js/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"ckeditor","slug":"ckeditor","link":"/tags/ckeditor/"},{"name":"ckeditor 5","slug":"ckeditor-5","link":"/tags/ckeditor-5/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"meta tags","slug":"meta-tags","link":"/tags/meta-tags/"},{"name":"ga","slug":"ga","link":"/tags/ga/"},{"name":"gtm","slug":"gtm","link":"/tags/gtm/"},{"name":"create-nuxt-app","slug":"create-nuxt-app","link":"/tags/create-nuxt-app/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"nuxt-vuex","slug":"nuxt-vuex","link":"/tags/nuxt-vuex/"},{"name":"swiper","slug":"swiper","link":"/tags/swiper/"}],"categories":[{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}