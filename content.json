{"pages":[],"posts":[{"title":"Nuxt.js 2.x nuxt.config.js 設定檔","text":"版本：nuxt 2.15.8 全名為 Nuxt configuration file，功能同 Vue 專案內 vue.config.js 檔，如果我們使用 create-nuxt-app 來建置專案，會自動產生這支檔案，在此配置的內容，會全域讀取設定。 接下來介紹一下一些常用的設定 alias路徑別名，大家還記得在 Vue 專案內，如果沒有設定路徑別名，則需要寫相對路徑（例如：../components/Navbar.vue），對於維護和開發都很不方便，一些程式碼檢核工具，甚至會視為 bad smell，因此我們會在 vue.config.js 檔內統一設定路徑別名。 Nuxt 專案很貼心的自動配置了路徑別名，預設值如下 { '~~': `&lt;rootDir&gt;`, '@@': `&lt;rootDir&gt;`, '~': `&lt;srcDir&gt;`, '@': `&lt;srcDir&gt;`, 'assets': `&lt;srcDir&gt;/assets`, // (unless you have set a custom `dir.assets`) 'static': `&lt;srcDir&gt;/static`, // (unless you have set a custom `dir.static`)} 因此在引入元件 Navbar 時可以寫成 @/components/Navbar.vue 如果需要更改配置也可以 import { resolve } from 'path';export default { alias: { 'images': resolve(__dirname, './assets/images'), '@static': resolve(__dirname, './static') }} ssrserver side render，預設為 true，如果不需 SEO，只要 spa 操作，設定 ssr: false 即可 💡 舊版會使用 mode: 'spa' 來進行設定，但官方文件有說明 v2.14.5 版本開始已棄用，改用 ssr: false export default { ssr: false // spa} server用來設定 port（預設 3000） 跟 host（預設 localhost） export default { server: { port: 8000, host: 'my-website' }} router配置 Nuxt 路由（vue-router），這裡以設定 base url 舉例，其他請參考官方文件 export default { router: { base: '/backoffice/' }} head在 Vue 專案，我們要設定 head 內容，只要在 public/index.html 檔設定就好了，但 Nuxt 專案又該怎麼設定呢？ 全域設定 在 nuxt.config.js 檔 head 內即可全域設定，通常在建立專案會預先帶入 export default { head: { title: 'test', htmlAttrs: { lang: 'en' }, meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: '' }, { name: 'format-detection', content: 'telephone=no' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] }} 這樣所有頁面都可以讀到 head 設定 單頁設定 Nuxt 專案很重要的一點是 SEO 效能優化，基於這點，通常會需要依照各頁設定自己的 SEO，例如pages/about.vue 頁面的 title 和 description 要單獨設定，方法也很簡單 export default { head: { title: '關於我們', meta: [ { hid: 'description', name: 'description', content: '這是關於我們頁面' } ] }} 在各頁面設定的內容優先度較高，會覆寫全域設定的 head 內容，因此當我們開啟 about 頁面，會看到 title 變成 關於我們、description 變成 這是關於我們頁面，其他配置則依照 nuxt.config.js 檔 css引入全域使用的 css 檔，像是外部套件，或是自訂檔，如果要使用 sass，必須安裝 sass-loader npm install --save-dev sass sass-loader export default { css: [ // 外部套件 { src: 'bootstrap-icons/font/bootstrap-icons.css' }, // scss 檔 { src: '@/assets/scss/app.scss', lang: 'scss' } ]} plugins全局引入外部套件，以 vue-notification 舉例，在 plugins 新增 notification.js 檔 // plugins/notification.jsimport Vue from 'vue';import Notifications from 'vue-notification';Vue.use(Notifications); 在 nuxt.config.js 配置 plugins export default { plugins: [ { src: '@/plugins/notification.js' } ]} 就可以在所有頁面中使用該套件 &lt;Notifications&gt;&lt;/Notifications&gt; components如設定為 true，會全局引入元件，使用方式只要遵循資料夾結構輸入元件名稱就可以了 export default { components: true} 範例： 元件路徑：components/home/Banner.vue 使用元件：&lt;HomeBanner&gt;&lt;/HomeBanner&gt; buildModules用來配置只在開發環境使用的模組，註冊在此可以讓專案在生產環境部署速度提升，並減少 node_modules 容量，詳情可以參考各套件的配置建議 @nuxtjs/eslint-module 套件官方建議配置於 buildModules export default { buildModules: [ '@nuxtjs/eslint-module' ]} 💡 使用條件：Nuxt 版本必須大於 v2.9 modules用來配置開發環境與生產環境共用模組，buildModules 及 modules 配置位置詳請參考各套件建議 export default { modules: [ '@nuxtjs/style-resources' ]} styleResources用來注入全域共用 sass, scss，如果不引入，在各頁面（.vue）內的 style 會無法使用像是 mixin 等的常用變數，或是要在各頁面單獨 @import scss 檔 首先必須另外安裝 @nuxtjs/style-resources 套件 執行：npm i @nuxtjs/style-resources 在 nuxt.config.js 檔設定 export default { modules: [ '@nuxtjs/style-resources' ], styleResources: { scss: [ '@/assets/scss/components/_color.scss', '@/assets/scss/components/_mixin.scss' ] }} 這樣就可以達到變數共用了 💡 官方文件 提到，請勿引入實際的 css 樣式，因為每個頁面跟元件都會重複編譯，造成系統極大負擔（筆者踩坑過OQ），建議只注入變數, mixins，因為這些值在編譯後就會消失了。 build客製化 webpack 設定，這裡舉例，在開發時，發現在 Vue 樣板無法使用可選串連 Optional Chaining（es2020語法），研究後發現必須需安裝擴充套件 npm install vue-template-babel-compiler --save-dev 接著在 nuxt.config.js 檔設定，就可以成功使用囉 export default { build: { loaders: { vue: { compiler: require('vue-template-babel-compiler') } } }} LoadingLoading 效果，基礎設定如下（參數選項） export default { loading: { color: 'black', height: '5px', continuous: true }} 如果想自訂更多樣式，也可以包裝成元件後引入 export default { loading: '@/components/TheLoading.vue'} env用來定義全局共用的環境變數，Nuxt 專案預設只有 nuxt.config.js 檔內可以讀取環境變數， 因此如果要讓 .vue 檔或是 .js 檔讀到變數，這裡提供以下兩個做法： 方法一：直接在 nuxt.config.js 檔內配置屬性 export default { env: { BASE_URL: process.env.BASE_URL }} 但有時變數多，不想各別配置，可以採用方法二 方法二：安裝套件 @nuxtjs/dotenv 執行：npm i @nuxtjs/dotenv，在 modules 內設定： export default { modules: [ '@nuxtjs/dotenv' ]} 這樣就可以全域使用 .env 變數囉。 專案如果有區分開發跟生產環境 .env 檔，也可以設定如下： export default { modules: [ [ '@nuxtjs/dotenv', { filename: `.env.${process.env.ENV}` } ] ]} 💡 使用方法二需注意，變數如果內含變數，會讀取不到第二層的變數（饒口），直接提供範例，假設在 .env 檔內有兩個變數BASE_DOMAIN=my-websitesBASE_URL=\"http://${BASE_DOMAIN}\"在 .vue 檔直接使用 process.env.BASE_URL，取得值為 http://${BASE_DOMAIN}，無法解析成 http://my-websites，此情況還是需搭配方法一使用 參考文章： https://ithelp.ithome.com.tw/articles/10207330 https://nuxtjs.org/docs/configuration-glossary https://hackmd.io/@xq/nuxt-config","link":"/2022/12/03/nuxt/nuxt-config-setting/"},{"title":"Nuxt.js 2.x 專案架設","text":"版本：nuxt 2.15.8 說到 Nuxt，必須先從 Vue.js 說起，Vue.js 為專注在視圖層(View) 的 JS 框架，為 SPA（Single Page Application）應用程式，簡而言之整個網站應用只有單一頁面，一但頁面被加載進來後，就不會再進行該頁面請求，由於 Vue 是利用 JS 載入資料，並動態產生元件，SEO 只能抓取到 HTML 內容，因此 SEO 表現趨近於零。 而 Nuxt 是基於 Vue.js、Node.js、Webpack 以及 Badel.js 的輕量框架，可以同時創建 SSR（Server Side Render）及 SPA，在頁面載入前即渲染（伺服器回傳完整 HTML 檔，每次跳轉頁面，瀏覽器都需要刷新），搜尋引擎爬蟲可以取得資料，大幅解決 SEO 的問題。 以下圖片說明： 接下來一起來嘗試創建一個 Nuxt 專案吧！ 如同 Vue CLI，Nuxt 也有類似的指令列(command-line)工具 create-nuxt-app， 依據官方文件提供的專案包建置方式： npx create-nuxt-app &lt;project-name&gt; 💡 使用 npx 安裝，安裝的套件在執行完後就會被移除 npx介紹 接著會跑出一些選項： Project name：設定專案名稱 Programming language：選擇程式語言 Package manager：軟體套件管理系統 npm / yarn UI framework：css 模板 Template engine：樣版引擎 Nuxt.js modules：相依套件 Linting tools：程式碼檢查工具 Testing framework：測試工具 Rendering mode：渲染模式 Deployment target：運行模式 （在此示範 Server Side Render) Development tools：開發工具 Version control system：版控工具 以上選擇完畢就開始安裝專案包 運行完成就可以開始編譯專案 跟著提示訊息執行： cd testnpm run dev 在 package.json 內可以看到相關指令 \"scripts\": { \"dev\": \"nuxt\", \"build\": \"nuxt build\", \"start\": \"nuxt start\", \"generate\": \"nuxt generate\"} 接下來就可以看到畫面囉 👏 參考文章： https://medium.com/web-design-zone/建立nuxt-js專案初體驗-21920735e38b https://levelup.gitconnected.com/spa-ssg-ssr-and-jamstack-a-front-end-acronyms-guide-6add9543f24d","link":"/2022/12/02/nuxt/nuxt-installation/"},{"title":"Nuxt.js 2.x 目錄結構","text":"版本：nuxt 2.15.8 使用 create-nuxt-app 安裝完成後，可以看到以下的資料夾結構 assets, layouts, middleware, mixins, plugins 以上資料夾在當前版本是需要手動建置的， 依照順序介紹各資料夾功能： assets跟 Vue 專案相同，用來存放像是 css, scss, images 需要被 webpack 編譯的靜態資源，如不需被編譯，則存放於 static。 components自訂的元件檔，例如我們常會建立共用的 Navbar.vue, Sidebar.vue …，通常為大寫命名，然後在需要的頁面引入該檔案即可使用，使用方式基本上跟 Vue 專案相同。 如果不想要個別引入元件，Nuxt 也有提供很便利的作法，只要在 nuxt.config.js 檔內設定： // nuxt.config.jsexport default { components: true} 就會全局引入元件，使用方式只要遵循資料夾結構輸入元件名稱就可以了 範例： 元件路徑：components/home/Banner.vue 使用元件：&lt;HomeBanner&gt;&lt;/HomeBanner&gt; layouts共用模板。 大家還記得在 Vue 專案下，只要在 App.vue，或是在 router 建立一個巢狀路由，外層設定共用容器，再將嵌套路由放入 children，子路由就可以共享外層模板 export default [ { path: '/products', component: Product, children: [ { path: 'food', component: Food }, { path: 'drink', component: Drink } ] }] 但是在 Nuxt 架構下，並不存在 App.vue 這隻檔案，router 也會自動配置，那該怎麼做到模板共用呢？其實很簡單，只要在 layouts 資料夾內，新增 default.vue 檔，預設所有 pages 內的檔案都會共享該版面 // default.vue&lt;template&gt; &lt;div class=\"default-wrap\"&gt; &lt;Navbar /&gt; &lt;Nuxt /&gt; &lt;Footer /&gt; &lt;/div&gt;&lt;/template&gt; &lt;Nuxt /&gt; 類似 Vue 的 &lt;router-view /&gt; （嵌套路由） 如果想要新增更多模板，只要在 layouts 內新增檔案，例如 layouts/products.vue，在欲使用的頁面引入，該頁就可以讀到 layouts/products.vue 模板 // pages/food.vueexport default { layout: 'products'} middleware前面有說到 Nuxt 專案會自動依 pages 內的資料夾結構產生對應的靜態/動態路由， 但如果說我們想要使用 路由守衛(Navigation Guards) 來進行路由監聽，像是 Vue router 內的 beforeEach callback，該怎麼做呢？ Vue 專案： // pages/food.vueconst router = new VueRouter({ mode: 'history', routes});router.beforeEach(async (to, from, next) =&gt; { if (!store.permissions.includes(route.path)) { next({ statusCode: 403 }); } next();});export default router; Nuxt 專案： 我們可以手動建立一個 middleware 資料夾，在裡面新增要進行路由監聽的檔案 routeAuth.js // middleware/routeAuth.jsexport default ({ from, route, redirect, store, error }) =&gt; { if (!store.isLogin) { redirect('/login'); } if (!store.permissions.includes(route.path)) { error({ statusCode: 403 }); }}; 然後在需要進行監聽的檔案加入 middleware // layouts/default.vueexport default { middleware: 'routeAuth', data() { return {}; }} 或是在 nuxt.config.js 設定全域監聽 // nuxt.config.jsexport default { router: { middleware: [ 'routeAuth' ] }} mixinsmixins 提供彈性方式讓頁面可以重複使用方法，可以包含任何 Vue 組件項目(data, computed, watch, 生命週期)，將共用方法包裝進去，首先在 mixins 新增檔案 mixins/utils.js // mixins/utils.jsexport default { data() { return { number: 0 }; } methods: { count() { this.number++; } }}; 全域註冊： 全域宣告 mixin 務必小心使用，因為會影響到所有 Vue 檔(pages, components) 在 mixins 新增一支檔案 global-mixins.js，將欲全域註冊的檔案加入 Vue 實例 // mixins/global-mixins.jsimport Vue from 'vue';import utils from '@/mixins/utils';// 避免重複註冊if (!Vue.__utils_mixin__) { Vue.__utils_mixin__ = true; Vue.mixin(utils);} 接著加入 nuxt.config.js 內 // nuxt.config.jsexport default { plugins:[ { src: '@/mixins/global-mixins' } ]} 局部註冊： 局部註冊很簡單，只要在欲使用檔案引入即可，這裡假設在 pages/about.vue // pages/about.vueimport utils from '@/mixins/utils';export default { name: 'About', mixins:[ utils ]} 這樣在 About 頁面就可以取得參數 number 的值跟呼叫 count() 方法囉！ pages主要的頁面檔案，Nuxt 專案會自動依照 pages 內的資料夾結構配置路由， 換句話說，就不需要像 Vue 專案一樣需要自行設定 vue-router，為小寫命名（命名會直接是路徑名稱），每個 .vue 檔都是已經被註冊的頁面 以首頁為例：pages/index.vue → http://localhost:3000 巢狀路由： 直接舉例，先建立一支檔案 pages/about.vue // pages/about/index.vue&lt;template&gt; &lt;div&gt; about： &lt;nuxt-child /&gt; &lt;/div&gt;&lt;/template&gt; 接在 about 資料夾新增兩隻檔案，可取得配置的巢狀路徑如下 pages/about/index.vue → http://localhost:3000/about pages/about/claire.vue → http://localhost:3000/about/claire 動態路由： 如果想要顯示動態路由，只要在檔名前加上下底線就可以了： pages/about/ _name.vue → http://localhost:3000/about/claire 這樣就可以在檔案內取得動態路由參數 // pages/about/_name.vueexport default { created () { console.log(this.$route.params.name); }} pluginsNuxt 插件，於 Vue.js 執行前引入第三方套件，以 vue-notification 為例 首先使用 npm 安裝 npm i vue-notification 然後在 plugins 資料夾新增 notification.js 檔 // plugins/notification.jsimport Vue from 'vue';import Notifications from 'vue-notification';Vue.use(Notifications); 在 nuxt.config.js 配置 plugins // nuxt.config.jsexport default { plugins: [ { src: '@/plugins/notification.js' } ]} 就可以在所有頁面中使用該套件 &lt;Notifications&gt;&lt;/Notifications&gt; static靜態資源資料夾，用來存放不需要被編譯的檔案，像是圖片檔，或是可以供使用者下載的範例檔等，如需被編譯，則存放於 assets。 store放置 Vuex 狀態管理工具，用來存放全域共用的方法、資料，使用方式與 Vue 大致相同，Vuex 在使用時會碰到一個問題，當頁面重新整理，其會被還原為初始狀態，至於要怎麼解決這個問題，後續會單獨介紹。 參考文章： https://israynotarray.com/vue/20211011/3406447097/ https://dev.to/husteadrobert/how-to-use-global-navigation-guards-with-nuxt-middleware-and-why-you-absolutely-should-not-7bl https://ithelp.ithome.com.tw/articles/10207822 https://medium.com/@seyijosh44/how-to-use-mixins-in-nuxt-js-826724fa251","link":"/2022/12/03/nuxt/nuxt-catalog/"},{"title":"Nuxt.js 2.x Lifecycle 生命週期","text":"版本：nuxt 2.15.8 Nuxt 最大的特點就是 Server Side Render，因此他有獨立的生命週期，來看一下官方提供的圖片： nuxtServerInit只在 Nuxt 環境初始化時觸發，當我們想將 server 端資料提前傳給 client 端，可以使用此方法，要注意只能寫在 VueX store/index.js actions // store/index.jsexport const state = () =&gt; ({ userInfo: {}});export const mutations = { setUserInfo(state, value) { state.userInfo = value; }};export const actions = { nuxtServerInit({ commit }, { req }) { // req.session.user = { name: 'claire' } commit('setUserInfo', req.session.user); }}; 這樣就可以在 Nuxt 初始化時，觸發 nuxtServerInit 方法，將值傳入 state，我們可以從瀏覽器 Vue 開發者工具看到內容： 如果想將資料傳給其他 VueX modules，可以這樣做： 首先新增一支檔案 store/greeting.js export const state = () =&gt; ({ message: ''});export const mutations = { setMessage(state, value) { state.message = value; }}; 接著在 store/index.js 定義 nuxtServerInit export const actions = { nuxtServerInit({ commit }, { req }) { commit('greeting/setMessage', 'Hello World!'); }}; 這樣就可以觸發 store/greeting.js setMessage 方法，見下圖開發者工具 Route Middleware中間組件，在頁面渲染前執行，有三種定義方式，執行順序為：Global → Layout → Page 接下來分別說明該如何定義 Global Middleware 在 middleware 資料夾內建立檔案，這裡命名為 global.js export default ({ from, route, redirect, store, error }) =&gt; { console.log('global middleware'); if (!store.isLogin) { redirect('/login'); }}; 接著在 nuxt.config.js 配置 export default { router: { middleware: [ 'global' ] }} Layout Middleware 建立 middleware 檔案，這裡命名為 middleware/layout.js，然後配置到任一 layouts 檔案，範例使用 layouts/default.vue export default { name: 'Default', middleware: 'layout'}; 或是匿名配置也可以： export default { name: 'Default', middleware({ from, route, redirect, store, error }) { console.log('layout middleware'); }}; Page Middleware 概念同 layouts middleware，配置於任一 pages 檔案，範例使用 pages/about.vue，這裡使用匿名配置來說明 export default { name: 'About', middleware({ from, route, redirect, store, error }) { console.log('page middleware'); }}; 接著我們從開發者工具查看 console 結果依序為下圖，因此我們可以透過 layout 跟 page middleware 來覆寫 global middleware validate於 pages 檔案配置此方法，用來驗證動態路由參數有效性，範例使用 pages/about/_userId.vue export default { name: 'User', validate({ params, query }) { return true; // 驗證通過 return false; // 驗證無效，會自動轉導 error page }} 💡 驗證通過必須 return true，否則會自動轉跳 404 error page asyncData於 server 端處理非同步的生命週期，在此傳入的內容可以被搜尋引擎爬蟲取得，是提升 SEO 效能的重點生命週期。 只會在頁面載入時調用，由於生命週期在 Vue 之前，因此無法取得 this ，且 asyncData 僅限 pages 底下頁面使用，方法內會自動帶入 context 參數，我們可以安裝 @nuxtjs/axios 套件，axios 會被注入進 context 內，我們可以物件解構方式使用（ { $axios, params } = context )（範例使用 pages/about.vue） export default { name: 'About', async asyncData({ $axios, params }) { const id = params.id; const { data } = await $axios.$get(`/api/user/${id}`); return { userName: data }; }} 透過 return value，資料被賦予進 Vue 實體，我們透過 this.userName 即可成功取值 &lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ userName }}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'About', async asyncData({ $axios, params }) { const id = params.id; const { data } = await $axios.$get(`/api/user/${id}`); return { userName: data }; }}&lt;/script&gt; 💡 data 如果有相同變數名稱，會在 asyncData 生命週期被複寫，所以除非需要再次修改變數，否則請避免重複命名變數 💡 asyncData 是在 server 端、路由更新前即調用，由於是在瀏覽器渲染前的生命週期，因此無法使用 loading placeholder，也不能使用瀏覽器相關 API fetchNuxt v2.12 新增功能，功能類似 asyncData ，在畫面渲染前，同時於 server 端跟 client 端的生命週期，可以使用於任一 .vue 頁面，由於是在 Vue created 之後，因此可以取得 this，初次載入頁面時，fetch 會在 server 端執行，如果是透過 &lt;nuxt-link&gt; 進行路由切換，fetch 在 client 端執行，因此可以在此生命週期加入 loading 效果 💡 &lt;nuxt-link&gt; 為 Nuxt 的路由切換元件，相當於 Vue.js 的 &lt;router-link&gt; ，因此我們只能使用內部連結，外部連結必須使用 &lt;a&gt; 標籤，透過 &lt;nuxt-link&gt; 切換路由，會被視為 SPA 頁面跳轉 以下說明使用方式 &lt;template&gt; &lt;ul&gt; &lt;li v-for=\"(post, key) in posts\" :key=\"key\"&gt; {{ post }} &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { posts: [] } }, async fetch() { const { data } = await this.$axios.$get('/api/posts'); this.posts = data; }}&lt;/script&gt; 如果要重複觸發 fetch 生命週期，可以使用 this.$fetch 來呼叫： &lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=\"(post, key) in posts\" :key=\"key\"&gt; {{ post }} &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"$fetch\"&gt;重新取得貼文&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 如果我們希望 fetch 只在 client 端運行，可以加上 fetchOnServer: false（預設 true） 取得 fetch 狀態我們可以透過 this.$fetchState 取得 fetch 當前執行狀態，有以下參數： pending：Boolean / 是否執行完成，可以在此加入 loading 效果（client 端） error：null or Error 物件 / 判斷是否發生錯誤 timestamp：整數 / 最後一次執行時間（搭配 activated 使用） 範例： &lt;template&gt; &lt;div&gt; &lt;p v-if=\"$fetchState.pending\"&gt;Loading...&lt;/p&gt; &lt;p v-if=\"$fetchState.error\"&gt;有東西出錯了&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { posts: [] } }, activated() { // 每 30 秒自動呼叫 fetch if (this.$fetchState.timestamp &lt;= Date.now() - 30000) { this.$fetch() } }, async fetch() { const { data } = await this.$axios.$get('/api/posts'); this.posts = data; }}&lt;/script&gt; 生命週期執行順序接著我們從瀏覽器開發者工具觀察生命週期執行順序 asyncData() { console.log('asyncData');},fetch() { console.log('fetch');},beforeCreate() { console.log('beforeCreate');},created() { console.log('created');},beforeMount() { console.log('beforeMount');} 可以發現，created 跟 beforeCreate 這兩個 Vue.js 生命週期會同時出現在 server 端跟 client 端，如果要避免方法被重複執行，可以這樣做： 加上 process.client 判斷 created(){ if (process.client){ // 執行內容 }} 使用 Nuxt fetch 生命週期 使用 Vue beforeMount 生命週期 參考文章： https://stackoverflow.com/questions/60411436/nuxtjs-page-is-created-twice https://happy9990929.github.io/2021/09/10/vue-nuxt-lifecycle-hooks/","link":"/2022/12/03/nuxt/nuxt-lifecycle/"}],"tags":[{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"nuxt.js","slug":"nuxt-js","link":"/tags/nuxt-js/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"create-nuxt-app","slug":"create-nuxt-app","link":"/tags/create-nuxt-app/"}],"categories":[{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"}]}